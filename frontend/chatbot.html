<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chatbot - Coin Dash</title>
    <link rel="stylesheet" href="assets/css/style.css">
    <!-- Marked.js for markdown processing -->
    <script src="https://cdn.jsdelivr.net/npm/marked@9.1.6/marked.min.js"></script>
    <!-- PapaParse for CSV parsing (optional data queries) -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
        /* Fullscreen body setup */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        
        body {
            display: flex;
            flex-direction: column;
        }
        
        header {
            flex-shrink: 0;
        }
        
        .chatbot-main {
            flex: 1;
            min-height: 0;
        }
        
        .message {
            margin-bottom: 15px;
            padding: 14px 18px;
            border-radius: 12px;
            max-width: 100%;
            min-width: 550px;
            width: 100%;
            display: block;
            word-wrap: break-word;
            white-space: pre-wrap;
            overflow-wrap: anywhere; /* prevent long tokens from overflowing */
            word-break: break-word;  /* ensure breaks on long URLs/words */
            line-height: 1.3;
            box-sizing: border-box;
        }
        /* Message row with avatar and alignment */
        .message-row {
            display: flex;
            align-items: flex-end;
            gap: 10px;
            margin-bottom: 12px;
            width: 100%;
        }
        .message-row.right {
            justify-content: flex-end;
        }
        
        /* ƒê·∫£m b·∫£o wrapper ch·ª©a message c√≥ ƒë·ªô r·ªông ph√π h·ª£p v√† ƒë·ªÅu nhau */
        .message-row > div:not(.avatar) {
            flex: 0 1 auto;
            min-width: 550px;
            max-width: 85%;
            display: flex;
            flex-direction: column;
        }
        
        /* ƒê·∫£m b·∫£o message b√™n trong wrapper c√≥ ƒë·ªô r·ªông ƒë·ªÅu */
        .message-row .message {
            width: 100%;
            max-width: 100%;
            min-width: 100%;
        }
        
        /* Responsive: ƒëi·ªÅu ch·ªânh cho m√†n h√¨nh nh·ªè */
        @media (max-width: 768px) {
            .message-row > div:not(.avatar) {
                min-width: 300px;
                max-width: 90%;
            }
            .message {
                min-width: 300px;
            }
        }
        
        /* Responsive: ƒëi·ªÅu ch·ªânh cho m√†n h√¨nh trung b√¨nh */
        @media (min-width: 769px) and (max-width: 1200px) {
            .message-row > div:not(.avatar) {
                min-width: 500px;
                max-width: 80%;
            }
            .message {
                min-width: 500px;
            }
        }
        .avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #e2e6ea;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: #495057;
            flex: 0 0 32px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
        }
        .avatar.bot { background: #dbeafe; color: #1d4ed8; }
        .avatar.user { background: #d1e7ff; color: #0b5ed7; }
        .message.bot { border-bottom-left-radius: 4px; }
        .message.user { border-bottom-right-radius: 4px; }
        .message .meta {
            margin-top: 4px;
            font-size: 11px;
            color: #888;
        }
        .message.user {
            background: #007bff;
            color: white;
            margin-left: auto;
            text-align: right;
            align-self: flex-end;
            box-shadow: 0 4px 12px rgba(13,110,253,0.15);
        }
        .message.bot {
            background: #ffffff; /* white background for better contrast on dark */
            color: #000000;      /* black text for maximum readability */
            margin-right: auto;
            align-self: flex-start;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border: 1px solid rgba(0,0,0,0.08);
        }
        
        /* ƒê·∫£m b·∫£o ti√™u ƒë·ªÅ trong bot message c√≥ m√†u ƒëen ƒë·∫≠m v√† r√µ r√†ng */
        .message.bot h1,
        .message.bot h2,
        .message.bot h3,
        .message.bot h4,
        .message.bot h5,
        .message.bot h6 {
            color: #000000 !important;
            font-weight: 700 !important;
        }
        
        /* ƒê·∫£m b·∫£o text th∆∞·ªùng trong bot message c≈©ng ƒë·ªß ƒë·∫≠m */
        .message.bot p,
        .message.bot li,
        .message.bot span {
            color: #1a1a1a;
        }
        .message.loading {
            background: #e9ecef;
            color: #666;
            font-style: italic;
        }
        .chat-input {
            padding: 16px 20px;
            background: #111827;
            border-top: 1px solid #2a2f3e;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .input-actions {
            display: flex;
            gap: 8px;
        }
        
        .input-action-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 18px;
        }
        
        .input-action-btn:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(34,197,94,0.5);
            transform: scale(1.05);
        }
        
        .chat-input textarea {
            width: 100%;
            padding: 14px 16px;
            border: 1px solid #2a2f3e;
            border-radius: 12px;
            resize: none;
            font-family: inherit;
            font-size: 14px;
            background: #0b0e11;
            color: #e5e7eb;
            line-height: 1.5;
            min-height: 60px;
            max-height: 200px;
        }
        
        .chat-input textarea:focus {
            outline: none;
            border-color: #22c55e;
            box-shadow: 0 0 0 3px rgba(34,197,94,0.1);
        }
        
        .chat-input textarea::placeholder {
            color: #6b7280;
        }
        
        .chat-actions {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: flex-end;
        }
        
        .chat-input button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(34,197,94,0.2);
        }
        
        .chat-input button:hover:not(:disabled) {
            background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(34,197,94,0.3);
        }
        
        .chat-input button:active:not(:disabled) {
            transform: translateY(0);
        }
        
        .chat-input button:disabled {
            background: #374151;
            cursor: not-allowed;
            box-shadow: none;
        }
        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        
        /* Markdown styling for chat messages */
        .message h1, .message h2, .message h3, .message h4, .message h5, .message h6 {
            margin: 6px 0 2px 0;
            font-weight: 700;
            line-height: 1.3;
            color: #000000; /* ƒê·∫£m b·∫£o ti√™u ƒë·ªÅ c√≥ m√†u ƒëen ƒë·∫≠m */
        }
        .message h1 { font-size: 1.5em; color: #000000; margin: 6px 0 2px 0; }
        .message h2 { font-size: 1.3em; color: #000000; margin: 6px 0 2px 0; }
        .message h3 { font-size: 1.2em; color: #000000; font-weight: 700; margin: 6px 0 2px 0; }
        
        .message p {
            margin: 2px 0;
            line-height: 1.3;
        }
        
        .message ul, .message ol {
            margin: 2px 0;
            padding-left: 20px;
        }
        
        .message li {
            margin: 1px 0;
            line-height: 1.3;
            padding-left: 4px;
        }
        
        /* ƒê·∫£m b·∫£o kho·∫£ng c√°ch ƒë·ªÅu gi·ªØa c√°c ph·∫ßn t·ª≠ trong message */
        .message > *:first-child {
            margin-top: 0;
        }
        
        .message > *:last-child {
            margin-bottom: 0;
        }
        
        .message code {
            background: rgba(0, 0, 0, 0.08);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.3;
        }
        
        .message pre {
            background: rgba(0, 0, 0, 0.05);
            padding: 10px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 4px 0;
            line-height: 1.3;
        }
        
        .message pre code {
            background: none;
            padding: 0;
        }
        
        .message blockquote {
            border-left: 4px solid #007bff;
            margin: 4px 0;
            padding-left: 15px;
            font-style: italic;
            color: #555;
            line-height: 1.3;
        }
        
        .message strong {
            font-weight: bold;
        }
        
        .message em {
            font-style: italic;
        }
        
        .message a { color: #0b5ed7; text-decoration: underline; }
        .message.user a { color: #eaf2ff; text-decoration: underline; } /* readable on blue bubble */
        .message code { color: inherit; }
        .message.user code { background: rgba(255,255,255,0.18); color: #fff; }
        .message img { max-width: 100%; height: auto; display: block; }
        
        .message table {
            border-collapse: collapse;
            width: 100%;
            margin: 4px 0;
        }
        
        .message th, .message td {
            border: 1px solid #ddd;
            padding: 6px 10px;
            text-align: left;
            line-height: 1.3;
        }
        
        .message th {
            background: rgba(0, 0, 0, 0.05);
            font-weight: bold;
        }
        
        /* Fullscreen Layout */
        .chatbot-main {
            display: flex;
            flex: 1;
            gap: 0;
            margin: 0;
            padding: 0;
            overflow: hidden;
            min-height: 0;
        }
        
        /* Sidebar Styles */
        .sidebar-features {
            width: 280px;
            min-width: 280px;
            background: linear-gradient(180deg, #1a1f2e 0%, #0f1419 100%);
            border-right: 1px solid #2a2f3e;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
        }
        
        .sidebar-features::-webkit-scrollbar {
            width: 6px;
        }
        
        .sidebar-features::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .sidebar-features::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
        }
        
        .sidebar-features::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #2a2f3e;
            background: rgba(255,255,255,0.02);
        }
        
        .sidebar-header h2 {
            margin: 0;
            font-size: 18px;
            font-weight: 700;
            color: #e5e7eb;
        }
        
        .sidebar-section {
            padding: 16px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        
        .sidebar-title {
            font-size: 13px;
            font-weight: 600;
            color: #9ca3af;
            margin: 0 0 12px 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .feature-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .feature-btn {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 14px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            color: #e5e7eb;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
            width: 100%;
        }
        
        .feature-btn:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(34,197,94,0.5);
            transform: translateX(4px);
        }
        
        .feature-btn .icon {
            font-size: 18px;
            flex-shrink: 0;
        }
        
        .upload-btn {
            position: relative;
        }
        
        .sidebar-footer {
            margin-top: auto;
            padding: 16px;
            border-top: 1px solid rgba(255,255,255,0.05);
        }
        
        .file-list-title {
            font-size: 13px;
            font-weight: 600;
            color: #9ca3af;
            margin: 0 0 12px 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .file-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: rgba(255,255,255,0.03);
            border-radius: 6px;
            margin-bottom: 6px;
            font-size: 12px;
            color: #d1d5db;
        }
        
        .file-item-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .file-item-remove {
            background: transparent;
            border: none;
            color: #ef4444;
            cursor: pointer;
            padding: 4px;
            font-size: 14px;
        }
        
        .file-item-remove:hover {
            color: #dc2626;
        }
        
        /* Chat Panel */
        .chat-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            background: #0b0e11;
        }
        
        .chat-panel .card {
            height: 100%;
            display: flex;
            flex-direction: column;
            border-radius: 0;
            border: none;
            background: #0b0e11;
        }
        
        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            overflow: hidden;
            min-height: 0;
            height: 100%;
        }
        
        .chat-messages {
            flex: 1 1 auto;
            overflow-y: auto;
            padding: 20px;
            background: #0b0e11;
            display: flex;
            flex-direction: column;
            min-width: 0;
            min-height: 0;
            height: 100%;
        }
        
        /* Chat Effects and Animations */
        .message {
            animation: slideIn 0.3s ease-out;
            transform: translateY(0);
            opacity: 1;
        }
        
        @keyframes slideIn {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .message.user {
            animation: slideInRight 0.3s ease-out;
        }
        
        .message.bot {
            animation: slideInLeft 0.3s ease-out;
        }
        
        @keyframes slideInRight {
            from {
                transform: translateX(30px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideInLeft {
            from {
                transform: translateX(-30px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        /* Typing Indicator */
        .typing-indicator {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            background: #e9ecef;
            border-radius: 8px;
            margin-bottom: 15px;
            max-width: 80px;
        }
        
        .typing-dots {
            display: flex;
            gap: 4px;
        }
        
        .typing-dot {
            width: 8px;
            height: 8px;
            background: #666;
            border-radius: 50%;
            animation: typingDot 1.4s infinite ease-in-out;
        }
        
        .typing-dot:nth-child(1) { animation-delay: -0.32s; }
        .typing-dot:nth-child(2) { animation-delay: -0.16s; }
        .typing-dot:nth-child(3) { animation-delay: 0s; }
        
        @keyframes typingDot {
            0%, 80%, 100% {
                transform: scale(0.8);
                opacity: 0.5;
            }
            40% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        /* Message hover effects */
        .message:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
        }
        
        /* Send button animation */
        .chat-input button {
            position: relative;
            overflow: hidden;
        }
        
        .chat-input button:active {
            transform: scale(0.95);
        }
        
        .chat-input button:disabled {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        /* Scrollbar styling */
        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }
        
        .chat-messages::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }
        
        .chat-messages::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }
        
        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }
        /* Utility row for actions */
        .chat-actions {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: space-between;
            margin-top: 8px;
        }
        .chat-actions button.small {
            padding: 6px 10px;
            font-size: 12px;
            background: #dc3545;
        }
        .chat-actions button.small:hover:not(:disabled) { background: #b02a37; }
        /* Chat header */
        .chat-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px 24px;
            border-bottom: 1px solid #2a2f3e;
            background: #111827;
        }
        
        .chat-header .title {
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 700;
            font-size: 18px;
            color: #e5e7eb;
        }
        
        .status {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #22c55e;
            font-weight: 500;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            background: #22c55e;
            border-radius: 50%;
            box-shadow: 0 0 0 0 rgba(34,197,94,0.6);
            animation: pulseDot 1.6s infinite;
        }
        
        @keyframes pulseDot {
            0% { box-shadow: 0 0 0 0 rgba(34,197,94,0.6); }
            70% { box-shadow: 0 0 0 8px rgba(34,197,94,0); }
            100% { box-shadow: 0 0 0 0 rgba(34,197,94,0); }
        }
        
        .chat-header .model {
            font-size: 12px;
            color: #9ca3af;
            font-weight: 500;
        }
        
        /* File preview in messages */
        .message-attachment {
            margin-top: 8px;
            padding: 12px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .message-attachment img {
            max-width: 100%;
            border-radius: 8px;
            margin-top: 8px;
        }
        
        .message-attachment-file {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #60a5fa;
        }
        
        .message-attachment-file::before {
            content: "üìÑ";
            font-size: 20px;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header>
        <nav class="navbar">
            <a href="index.html" class="logo">Coin Dash</a>
            <ul class="nav-menu">
                <li><a href="index.html">Home</a></li>
                <li><a href="dashboard.html">Dashboard</a></li>
                <li><a href="chart.html">Charts</a></li>
                <li><a href="chatbot.html" class="active">Chatbot</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content - Fullscreen -->
    <main class="chatbot-main">
        <!-- Sidebar -->
        <aside class="sidebar-features">
            <div class="sidebar-header">
                <h2>‚öôÔ∏è T√≠nh nƒÉng</h2>
            </div>
            
            <div class="sidebar-section">
                <h3 class="sidebar-title">üìÅ File & H√¨nh ·∫£nh</h3>
                <div class="feature-buttons">
                    <label class="feature-btn upload-btn" for="fileUpload">
                        <span class="icon">üìÑ</span>
                        <span>T·∫£i l√™n File</span>
                        <input type="file" id="fileUpload" accept=".txt,.csv,.json,.pdf,.doc,.docx" style="display: none;" onchange="handleFileUpload(event)">
                    </label>
                    <label class="feature-btn upload-btn" for="imageUpload">
                        <span class="icon">üñºÔ∏è</span>
                        <span>T·∫£i l√™n ·∫¢nh</span>
                        <input type="file" id="imageUpload" accept="image/*" style="display: none;" onchange="handleImageUpload(event)">
                    </label>
                    <button class="feature-btn" onclick="exportChat()">
                        <span class="icon">üíæ</span>
                        <span>Xu·∫•t Chat</span>
                    </button>
                    <button class="feature-btn" onclick="importChat()">
                        <span class="icon">üì•</span>
                        <span>Nh·∫≠p Chat</span>
                    </button>
                </div>
            </div>

            <div class="sidebar-section">
                <h3 class="sidebar-title">üìä Ph√¢n t√≠ch nhanh</h3>
                <div class="feature-buttons">
                    <button class="feature-btn" onclick="quickAsk('Cho m√¨nh xem xu h∆∞·ªõng gi√° BTC')">
                        <span class="icon">üìà</span>
                        <span>Xu h∆∞·ªõng BTC</span>
                    </button>
                    <button class="feature-btn" onclick="quickAsk('Gi√° trung b√¨nh c·ªßa ETH l√† bao nhi√™u?')">
                        <span class="icon">üí∞</span>
                        <span>Gi√° TB ETH</span>
                    </button>
                    <button class="feature-btn" onclick="quickAsk('Hi·ªÉn th·ªã correlation heatmap')">
                        <span class="icon">üî•</span>
                        <span>Heatmap</span>
                    </button>
                    <button class="feature-btn" onclick="quickAsk('Ph√¢n t√≠ch t·ªïng quan th·ªã tr∆∞·ªùng crypto')">
                        <span class="icon">üìä</span>
                        <span>Ph√¢n t√≠ch t·ªïng quan</span>
                    </button>
                </div>
            </div>

            <div class="sidebar-section">
                <h3 class="sidebar-title">‚ö° C√¥ng c·ª•</h3>
                <div class="feature-buttons">
                    <button class="feature-btn" onclick="clearHistory()">
                        <span class="icon">üóëÔ∏è</span>
                        <span>X√≥a l·ªãch s·ª≠</span>
                    </button>
                    <button class="feature-btn" onclick="toggleTheme()">
                        <span class="icon">üåô</span>
                        <span>ƒê·ªïi theme</span>
                    </button>
                    <button class="feature-btn" onclick="showCapabilities()">
                        <span class="icon">‚ùì</span>
                        <span>H∆∞·ªõng d·∫´n</span>
                    </button>
                </div>
            </div>

            <div class="sidebar-footer">
                <div class="file-list" id="uploadedFiles">
                    <h4 class="file-list-title">üìé File ƒë√£ t·∫£i</h4>
                    <div id="fileListContainer"></div>
                </div>
            </div>
        </aside>

        <!-- Chat Panel (full width) -->
        <div class="chat-panel">
            <div class="card">
                <div class="chat-header">
                    <div class="title">
                        ü§ñ Llama Assistant
                        <span class="status"><span class="status-dot"></span> Online</span>
                    </div>
                    <div class="model">v1 ‚Ä¢ Markdown enabled ‚Ä¢ File & Image support</div>
                </div>
                
                <!-- Error Message -->
                <div id="errorMessage" class="error-message" style="display: none;"></div>
                
                <!-- Chat Messages -->
                <div class="chat-container">
                    <div class="chat-messages" id="chatMessages">
                        <!-- Bot Welcome Message -->
                        <div class="message-row">
                            <div class="avatar bot">AI</div>
                            <div>
                                <div class="message bot">
                                    <h3>Ch√†o m·∫•y coin th·ªß nh√°! üöÄ</h3>
                                    <p>T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:</p>
                                    <ul>
                                        <li><strong>Ph√¢n t√≠ch</strong> gi√° crypto</li>
                                        <li><em>D·ª± ƒëo√°n</em> xu h∆∞·ªõng th·ªã tr∆∞·ªùng</li>
                                        <li>Gi·∫£i th√≠ch c√°c <code>ch·ªâ s·ªë k·ªπ thu·∫≠t</code></li>
                                        <li>T∆∞ v·∫•n ƒë·∫ßu t∆∞</li>
                                        <li><strong>ƒê·ªçc file</strong> CSV, TXT, JSON</li>
                                        <li><strong>Ph√¢n t√≠ch ·∫£nh</strong> bi·ªÉu ƒë·ªì, charts</li>
                                    </ul>
                                    <p>C·∫ßn gi√∫p g√¨ tui gi√∫p cho nha! üí∞</p>
                                </div>
                                <div class="meta">V·ª´a xong</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Chat Input -->
                    <div class="chat-input">
                        <div class="input-actions">
                            <label class="input-action-btn" for="imageUploadInput" title="T·∫£i ·∫£nh">
                                üñºÔ∏è
                                <input type="file" id="imageUploadInput" accept="image/*" style="display: none;" onchange="handleImageUpload(event)">
                            </label>
                            <label class="input-action-btn" for="fileUploadInput" title="T·∫£i file">
                                üìÑ
                                <input type="file" id="fileUploadInput" accept=".txt,.csv,.json,.pdf,.doc,.docx" style="display: none;" onchange="handleFileUpload(event)">
                            </label>
                        </div>
                        <textarea id="messageInput" placeholder="Nh·∫≠p tin nh·∫Øn... (Shift+Enter ƒë·ªÉ xu·ªëng d√≤ng)" rows="3"></textarea>
                        <div class="chat-actions">
                            <button id="sendButton" onclick="sendMessage()">G·ª≠i</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Footer - Hidden for fullscreen -->
    <footer style="display: none;">
        <p>Code by Mital</p>
    </footer>

    <script>
        // Backend API base (ngrok public URL)
        const BACKEND_URL = 'https://isaiah-pretonic-tory.ngrok-free.dev';
        
        const SYSTEM_PROMPT = `
B·∫°n l√† Ng∆∞·ªùi t∆∞ v·∫•n t√†i ch√≠nh ho·∫°t ƒë·ªông trong m√¥i tr∆∞·ªùng tr√¨nh duy·ªát.
B·∫°n KH√îNG th·ªÉ ch·∫°y Python ho·∫∑c code.
T·∫•t c·∫£ d·ªØ li·ªáu ƒë√£ c√≥ s·∫µn trong h·ªá th·ªëng qua 2 ngu·ªìn:

1Ô∏è‚É£ D·ªØ li·ªáu CSV t·∫°i ./data/
   - Ch·ª©a c√°c file dataset_{symbol}_clean.csv v√† dataset_{symbol}_scaled.csv.
   - C√°c c·ªôt ch√≠nh: Date, Open, High, Low, Close, Volume, funding_Rate, log_return, pct_change, ...
   - C√≥ th·ªÉ truy c·∫≠p b·∫±ng h√†m tryComputeValueFromCSV(symbol, metric).

2Ô∏è‚É£ Bi·ªÉu ƒë·ªì c√≥ trong manifest.json
   - D·∫°ng:
     {
       "BTC": { "charts": { "price_trend": "data/BTC/pic/area_close.png", ... } },
       "ALL": { "charts": { "heatmap_correlation": "data/picture/heatmap_correlation.png" } }
     }

H∆∞·ªõng d·∫´n tr·∫£ l·ªùi:
- N·∫øu ng∆∞·ªùi d√πng h·ªèi v·ªÅ d·ªØ li·ªáu (vd: "gi√° trung b√¨nh", "volume cao nh·∫•t"), tr·∫£ JSON:
  {"type":"data","symbol":"BTC","metric":"avg_close"}

- N·∫øu ng∆∞·ªùi d√πng h·ªèi v·ªÅ bi·ªÉu ƒë·ªì (vd: "v·∫Ω bi·ªÉu ƒë·ªì gi√°", "heatmap t∆∞∆°ng quan"), tr·∫£ JSON:
  {"type":"chart","symbol":"BTC","chart":"price_trend"}

- N·∫øu ng∆∞·ªùi d√πng h·ªèi ph√¢n t√≠ch t·ªïng quan, tr·∫£:
  {"type":"text","content":"...ph√¢n t√≠ch chi ti·∫øt..."}

L∆∞u √Ω: h√£y tr·∫£ l·ªùi k·∫øt h·ª£p v·ªõi vi·ªác s·ª≠ d·ª•ng d·ªØ li·ªáu li√™n quan trong c√°c file d·ªØ li·ªáu . ∆∞u ti√™n s·ª≠ d·ª•ng ti·∫øng vi·ªát khi tr·∫£ l·ªùi 

‚ö†Ô∏è KH√îNG sinh code Python, pandas, matplotlib.
‚ö†Ô∏è Kh√¥ng tr·∫£ l·ªùi v·ªõi d·∫°ng b·∫Øt ng∆∞·ªùi d√πng ƒë·ªçc file, ƒë∆∞a ra con s·ªë ƒë√°p ·ª©ng v·ªõi c√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng ƒë∆∞·ª£c l·∫•y trong dataset li√™n quan 
‚ö†Ô∏è Lu√¥n tr·∫£ JSON h·ª£p l·ªá, kh√¥ng c√≥ code block ho·∫∑c markdown.
‚ö†Ô∏è Lu√¥n tr·∫£ l·ªùi b·∫±ng ti·∫øng vi·ªát n·∫øu ng∆∞·ªùi d√πng h·ªèi b·∫±ng ti·∫øng vi·ªát.
`;

        
        // Global state
        let chatHistory = [];
        let manifest = null; // loaded from ../data/picture/manifest.json
        let csvData = null; // optional dataset cache
        let contextInjected = false;
        let systemInjected = false;
        let uploadedFiles = []; // Store uploaded files info
        let currentAttachments = []; // Store current message attachments (files/images)
        
        // Allow Enter key to send message (Shift+Enter for new line)
        document.getElementById('messageInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
        
        // On page load: load manifest, CSV (optional), and history
        window.addEventListener('DOMContentLoaded', async () => {
            loadHistoryFromStorage();
            await loadManifest();
            // Optional CSV load (non-blocking)
            loadCSVOptional();
            // Load per-symbol CSVs for data computations
            loadPerSymbolCSVs();
        });

        async function loadManifest() {
            try {
                const res = await fetch('../data/picture/manifest.json');
                if (!res.ok) throw new Error('Failed to load manifest.json');
                manifest = await res.json();
            } catch (err) {
                console.error('Manifest load error:', err);
            }
        }

        function loadCSVOptional() {
            const csvUrl = '../data/dataset_scaled_total.csv';
            Papa.parse(csvUrl, {
                download: true,
                header: true,
                dynamicTyping: true,
                complete: (results) => { csvData = results.data; },
                error: (error) => { console.warn('CSV load skipped/failed:', error); }
            });
        }

        // Load individual symbol CSVs into window.csvData[symbol]
        function loadPerSymbolCSVs() {
            try {
                const symbols = ['BTC','ETH','BNB','SOL','XRP'];
                window.csvData = window.csvData || {};
                for (const sym of symbols) {
                    const url = `../data/${sym}/dataset_${sym}_clean.csv`;
                    Papa.parse(url, {
                        download: true,
                        header: true,
                        dynamicTyping: true,
                        complete: (results) => { window.csvData[sym] = results.data || []; },
                        error: () => { /* non-fatal */ }
                    });
                }
            } catch {}
        }

        function saveHistoryToStorage() {
            try {
                const simple = chatHistory.map(m => ({ role: m.role, parts: m.parts }));
                localStorage.setItem('chatHistory', JSON.stringify(simple));
            } catch {}
        }

        function loadHistoryFromStorage() {
            try {
                const raw = localStorage.getItem('chatHistory');
                if (!raw) return;
                const arr = JSON.parse(raw);
                if (!Array.isArray(arr)) return;
                chatHistory = arr;
                // Re-render
                for (const msg of chatHistory) {
                    const text = (msg.parts && msg.parts[0] && msg.parts[0].text) ? msg.parts[0].text : '';
                    addMessage(text, msg.role === 'user' ? 'user' : 'bot');
                }
                contextInjected = !!arr.find(m => (m.role === 'user' && m.parts && m.parts[0] && (m.parts[0].text||'').includes('B·∫°n l√† AI h·ªó tr·ª£ ph√¢n t√≠ch d·ªØ li·ªáu crypto.')));
            } catch {}
        }
        
        function clearHistory() {
            chatHistory = [];
            localStorage.removeItem('chatHistory');
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.innerHTML = '';
            // Add welcome again
            addMessage(`### Ch√†o m·∫•y coin th·ªß nh√°! üöÄ\n\nT√¥i c√≥ th·ªÉ gi√∫p b·∫°n:\n- Ph√¢n t√≠ch gi√° crypto\n- D·ª± ƒëo√°n xu h∆∞·ªõng th·ªã tr∆∞·ªùng\n- Gi·∫£i th√≠ch c√°c \`ch·ªâ s·ªë k·ªπ thu·∫≠t\`\n- T∆∞ v·∫•n ƒë·∫ßu t∆∞\n\nC·∫ßn gi√∫p g√¨ tui gi√∫p cho nha! üí∞`, 'bot');
        }
        
        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            // Disable button and clear input
            const sendButton = document.getElementById('sendButton');
            sendButton.disabled = true;
            input.value = '';
            
            // Add user message to chat
            addMessage(message, 'user');
            
            // First, intent detection for charts or simple data queries
            const handled = await tryHandleIntent(message);
            if (handled) {
                // Re-enable and save
                sendButton.disabled = false;
                input.focus();
                saveHistoryToStorage();
                return;
            }

            // Show typing indicator (custom message)
            const typingId = addTypingIndicator();
            
            try {
                // Sanitize message
                const safeMsg = message
                  .replace(/[`$]/g, "")
                  .replace(/["']/g, "");

                if (!safeMsg.trim()) {
                    const chatMessages = document.getElementById('chatMessages');
                    if (chatMessages.contains(typingId)) chatMessages.removeChild(typingId);
                    addMessage("‚ö†Ô∏è Tin nh·∫Øn tr·ªëng ho·∫∑c kh√¥ng h·ª£p l·ªá.", 'bot');
                    sendButton.disabled = false;
                    input.focus();
                    return;
                }

                // Build history for backend (map local history to {role, content})
                const mappedHistory = (chatHistory || [])
                  .map(m => {
                      const text = (m.parts && m.parts[0] && m.parts[0].text) ? m.parts[0].text : '';
                      if (!text) return null;
                      if (m.role === 'user') return { role: 'user', content: text };
                      if (m.role === 'model') return { role: 'assistant', content: text };
                      if (m.role === 'system') return { role: 'system', content: text };
                      return null;
                  })
                  .filter(Boolean)
                  .slice(-10); // keep last 10

                // Inject AI personality as system prompt
                const systemPersona = {
                    role: 'system',
                    content: 'You are a professional Data Analyst Assistant. Communicate clearly with structured output. When analyzing data or charts, follow this style:\n\nInsight first\n\nShort explanation\n\nWhen needed, return output formatted in markdown'
                };

                // Prepare attachments (files/images) for current message
                const attachments = [];
                if (currentAttachments.length > 0) {
                    for (const att of currentAttachments) {
                        if (att.type === 'image' && att.data) {
                            attachments.push({
                                type: 'image',
                                data: att.data, // base64 data URL
                                name: att.name
                            });
                        } else if (att.type === 'file' && att.content) {
                            attachments.push({
                                type: 'file',
                                content: att.content, // text content
                                name: att.name,
                                mimeType: att.mimeType
                            });
                        }
                    }
                }

                // Call Flask/Ollama backend
                const response = await fetch(`${BACKEND_URL}/chat`, {
                    method: 'POST',
                    mode: 'cors',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message: safeMsg,
                        history: [systemPersona, ...mappedHistory],
                        attachments: attachments.length > 0 ? attachments : undefined
                    })
                });
                
                // Clear attachments after sending
                currentAttachments = [];

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Backend error ${response.status}: ${errorText}`);
                }

                const data = await response.json();
                const botResponse = (data && typeof data.reply === 'string') ? data.reply : '';

                // Parse optional JSON intent from model reply
                let parsed = parseModelJson(botResponse);

                // Simulate typing delay
                setTimeout(() => {
                    const chatMessages = document.getElementById('chatMessages');
                    if (chatMessages.contains(typingId)) chatMessages.removeChild(typingId);

                    let finalShown = false;
                    if (parsed && typeof parsed === 'object' && parsed.type) {
                        if (parsed.type === 'chart' && parsed.symbol && parsed.chart) {
                            const sym = String(parsed.symbol).toUpperCase();
                            const chartKey = String(parsed.chart);
                            const symEntry = manifest && (manifest[sym] || manifest['ALL'] || manifest['BTC']);
                            const chartPath = symEntry && symEntry.charts ? (symEntry.charts[chartKey] || null) : null;
                            if (chartPath) {
                                const html = `<b>${sym} - ${chartKey}</b><br><img src="${rewriteImagePath(chartPath)}" width="420">`;
                                addMessage(html, 'bot');
                                chatHistory.push({ role: 'model', parts: [{ text: html }] });
                                finalShown = true;
                            }
                        }
                        if (!finalShown && parsed.type === 'data' && parsed.symbol) {
                            const sym = String(parsed.symbol).toUpperCase();
                            const avg = tryComputeAveragePricePerSymbol(sym);
                            if (avg != null && !isNaN(avg)) {
                                let combined = `üíπ Gi√° trung b√¨nh c·ªßa ${sym} ‚âà <b>${Number(avg).toFixed(2)}</b>`;
                                const hasCharts = manifest && manifest[sym] && manifest[sym].charts;
                                const priceChartPath = hasCharts ? (manifest[sym].charts['price_trend'] || null) : null;
                                if (priceChartPath) {
                                    combined += `\n<p style=\"margin-top:8px;\"><b>${sym} - ${chartTitle('price_trend')}</b></p>\n<img src=\"${rewriteImagePath(priceChartPath)}\" width=\"400\">`;
                                }
                                addMessage(combined, 'bot');
                                chatHistory.push({ role: 'model', parts: [{ text: combined }] });
                                finalShown = true;
                            }
                        }
                        if (!finalShown && parsed.type === 'text' && parsed.content) {
                            addMessage(`<b>AI:</b> ${String(parsed.content)}`, 'bot');
                            chatHistory.push({ role: 'model', parts: [{ text: String(parsed.content) }] });
                            finalShown = true;
                        }
                    }

                    if (!finalShown) {
                        const textOut = botResponse || '‚ö†Ô∏è Kh√¥ng c√≥ ph·∫£n h·ªìi t·ª´ AI.';
                        addMessage(`<b>AI:</b> ${textOut}`, 'bot');
                        chatHistory.push({ role: 'model', parts: [{ text: textOut }] });
                    }

                    saveHistoryToStorage();
                    document.getElementById('errorMessage').style.display = 'none';
                    sendButton.disabled = false;
                    input.focus();
                }, Math.random() * 600 + 400);

            } catch (error) {
                console.error('Error:', error);
                
                // Remove typing indicator
                const chatMessages = document.getElementById('chatMessages');
                if (chatMessages.contains(typingId)) {
                    chatMessages.removeChild(typingId);
                }
                
                // Show error message with helpful details
                const errorDiv = document.getElementById('errorMessage');
                errorDiv.innerHTML = `
                    <strong>Error:</strong> ${error.message}<br>
                    <small>Kh√¥ng th·ªÉ k·∫øt n·ªëi backend. Ki·ªÉm tra Flask v√† ngrok (URL, CORS).</small>
                `;
                errorDiv.style.display = 'block';
                
                // Add error message to chat
                addMessage('Xin l·ªói, c√≥ l·ªói khi k·∫øt n·ªëi ƒë·∫øn API. Vui l√≤ng ki·ªÉm tra server Flask/ngrok v√† th·ª≠ l·∫°i.', 'bot');
                
                // Re-enable button
                sendButton.disabled = false;
                input.focus();
            }
        }
        
        function addTypingIndicator() {
            const chatMessages = document.getElementById('chatMessages');
            const typingDiv = document.createElement('div');
            typingDiv.className = 'typing-indicator';
            typingDiv.innerHTML = `üîç ƒêang ph√¢n t√≠ch d·ªØ li·ªáu, ch·ªù ch√∫t nh√©‚Ä¶`;
            chatMessages.appendChild(typingDiv);
            
            // Scroll to bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            return typingDiv;
        }
        
        function addMessage(text, role) {
            const chatMessages = document.getElementById('chatMessages');
            const row = document.createElement('div');
            row.className = `message-row ${role === 'user' ? 'right' : ''}`;

            const avatar = document.createElement('div');
            avatar.className = `avatar ${role}`;
            avatar.textContent = role === 'user' ? 'You' : 'AI';

            const wrapper = document.createElement('div');
            const bubble = document.createElement('div');
            bubble.className = `message ${role}`;

            if (role === 'bot') {
                marked.setOptions({ breaks: true, gfm: true, sanitize: false, smartLists: true, smartypants: true });
                let htmlContent = marked.parse(text);
                htmlContent = htmlContent.replace(/<a href=\"([^\"]+\.png)\"[^>]*>[^<]*<\/a>/gi, (m, p1) => {
                    const src = rewriteImagePath(p1);
                    return `<img src="${src}" alt="image" style="max-width: 100%; height: auto;"/>`;
                });
                htmlContent = htmlContent.replace(/(https?:[^\s)]+\.png)/gi, (m) => {
                    const src = rewriteImagePath(m);
                    return `<img src="${src}" alt="image" style="max-width: 100%; height: auto;"/>`;
                });
                bubble.innerHTML = htmlContent;
            } else {
                bubble.textContent = text;
            }

            const meta = document.createElement('div');
            meta.className = 'meta';
            meta.textContent = formatTime(new Date());

            wrapper.appendChild(bubble);
            wrapper.appendChild(meta);

            if (role === 'user') {
                // Right side: bubble then avatar
                row.appendChild(wrapper);
                row.appendChild(avatar);
            } else {
                // Left side: avatar then bubble
                row.appendChild(avatar);
                row.appendChild(wrapper);
            }

            chatMessages.appendChild(row);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            return row;
        }

        function formatTime(date) {
            try {
                const h = String(date.getHours()).padStart(2, '0');
                const m = String(date.getMinutes()).padStart(2, '0');
                return `${h}:${m}`;
            } catch { return ''; }
        }

        function quickAsk(text) {
            const input = document.getElementById('messageInput');
            input.value = text;
            sendMessage();
        }

        // Robustly parse model output that may include fenced code blocks like ```json ... ```
        function parseModelJson(text) {
            if (!text || typeof text !== 'string') return null;
            let cleaned = text.trim();
            // Remove markdown code fences and language hints
            cleaned = cleaned.replace(/```\s*json\s*/gi, '').replace(/```/g, '').trim();
            // Try direct parse first
            try { return JSON.parse(cleaned); } catch (_) {}
            // Fallback: extract the first JSON object substring
            const match = cleaned.match(/\{[\s\S]*\}/);
            if (match) {
                try { return JSON.parse(match[0]); } catch (_) {}
            }
            return null;
        }

        function rewriteImagePath(path) {
            // Ensure images load from GitHub Pages with ../ prefix when needed
            if (path.startsWith('data/')) return `../${path}`;
            if (path.startsWith('/data/')) return `..${path}`;
            return path;
        }

        function getContextPrompt() {
            return `B·∫°n l√† AI h·ªó tr·ª£ ph√¢n t√≠ch d·ªØ li·ªáu crypto.\nC√°c bi·ªÉu ƒë·ªì v√† d·ªØ li·ªáu hi·ªán c√≥ n·∫±m trong th∆∞ m·ª•c /data/{symbol}/pic/ v√† m√¥ t·∫£ trong manifest.json.\nKhi ng∆∞·ªùi d√πng h·ªèi v·ªÅ ph√¢n t√≠ch, h√£y k·∫øt h·ª£p insight ƒë·ªãnh t√≠nh (AI) v·ªõi d·ªØ li·ªáu ƒë·ªãnh l∆∞·ª£ng (manifest).`;
        }

        async function tryHandleIntent(userText) {
            const text = userText.toLowerCase();
            const symbol = detectSymbol(text) || 'BTC';
            const intent = detectChartIntent(text);

            // Capabilities/help intent
            if (detectCapabilitiesIntent(text)) {
                const html = buildCapabilitiesMessage();
                addMessage(html, 'bot');
                chatHistory.push({ role: 'user', parts: [{ text: userText }] });
                chatHistory.push({ role: 'model', parts: [{ text: html }] });
                saveHistoryToStorage();
                return true;
            }

            // ‚úÖ Updated: handle average price before chart intent
            if (csvData) {
                const avg = tryComputeAveragePriceFromTotalCSV(text, symbol);
                if (avg != null && !isNaN(avg)) {
                    const avgHtml = `üíπ Gi√° trung b√¨nh c·ªßa ${symbol} trong dataset ‚âà <b>${Number(avg).toFixed(2)}</b>`;

                    // If related chart exists, append it right after the number
                    let combinedHtml = avgHtml;
                    const hasCharts = manifest && manifest[symbol] && manifest[symbol].charts;
                    const priceChartPath = hasCharts ? (manifest[symbol].charts['price_trend'] || null) : null;
                    if (priceChartPath) {
                        combinedHtml += `\n<p style="margin-top:8px;"><b>${symbol} - ${chartTitle('price_trend')}</b></p>\n<img src="${rewriteImagePath(priceChartPath)}" width="400">`;
                    }

                    addMessage(combinedHtml, 'bot');
                    // Save to history
                    chatHistory.push({ role: 'user', parts: [{ text: userText }] });
                    chatHistory.push({ role: 'model', parts: [{ text: combinedHtml }] });
                    saveHistoryToStorage();
                    return true;
                }
            }

            // Chart-only flow (when user asks for chart but not average)
            if (intent && manifest && manifest[symbol] && manifest[symbol].charts) {
                const chartPath = manifest[symbol].charts[intent];
                if (chartPath) {
                    const prettyTitle = chartTitle(intent);
                    const html = `<p><b>${symbol} - ${prettyTitle}</b></p>\n<img src="${rewriteImagePath(chartPath)}" width="400">`;
                    addMessage(html, 'bot');
                    // Save to history
                    chatHistory.push({ role: 'user', parts: [{ text: userText }] });
                    chatHistory.push({ role: 'model', parts: [{ text: html }] });
                    saveHistoryToStorage();
                    return true;
                }
            }
            return false;
        }

        function detectSymbol(text) {
            const symbols = ['BTC','ETH','BNB','SOL','XRP'];
            for (const s of symbols) { if (text.includes(s.toLowerCase())) return s; }
            return null;
        }

        function detectCapabilitiesIntent(text) {
            return /\b(ban|b·∫°n).*\b(c√≥ th·ªÉ|l√†m ƒë∆∞·ª£c|hi·ªÉn th·ªã|show)\b|lo·∫°i\s*d·ªØ\s*li·ªáu\s*n√†o|what\s+can\s+you\s+do|support|h·ªó\s*tr·ª£\s*d·ªØ\s*li·ªáu/i.test(text);
        }

        function buildCapabilitiesMessage() {
            return [
                '### üß≠ T√¥i c√≥ th·ªÉ hi·ªÉn th·ªã nh·ªØng g√¨?',
                '',
                '**D·ªØ li·ªáu (type: "data")**',
                '',
                '| Metric | √ù nghƒ©a | V√≠ d·ª• truy v·∫•n |',
                '|---|---|---|',
                '| `avg_close` | Gi√° ƒë√≥ng c·ª≠a trung b√¨nh | "BTC gi√° trung b√¨nh" |',
                '| `latest_close` | Gi√° ƒë√≥ng c·ª≠a m·ªõi nh·∫•t | "ETH latest close" |',
                '| `max_close` | Gi√° ƒë√≥ng c·ª≠a cao nh·∫•t | "BNB max close" |',
                '| `min_close` | Gi√° ƒë√≥ng c·ª≠a th·∫•p nh·∫•t | "SOL min close" |',
                '| `volume` | Kh·ªëi l∆∞·ª£ng giao d·ªãch | "XRP volume" |',
                '| `funding_rate` | Funding rate (n·∫øu c√≥) | "BTC funding rate" |',
                '',
                '**Bi·ªÉu ƒë·ªì (type: "chart")**',
                '- `price_trend`: Xu h∆∞·ªõng gi√°',
                '- `volume_weekly`: Kh·ªëi l∆∞·ª£ng theo tu·∫ßn',
                '- `correlation_heatmap`: Ma tr·∫≠n t∆∞∆°ng quan',
                '- `funding_vs_close`, `volatility`, `composition`, `sentiment_trend`, `moving_average`, `rsi_indicator`',
                '',
                'B·∫°n c√≥ th·ªÉ h·ªèi t·ª± nhi√™n, v√≠ d·ª•:',
                '- "Cho m√¨nh xem xu h∆∞·ªõng gi√° BTC"',
                '- "Gi√° trung b√¨nh c·ªßa ETH l√† bao nhi√™u?"',
                '- "Hi·ªÉn th·ªã correlation heatmap"'
            ].join('\n');
        }

        function detectChartIntent(text) {
            // Map keywords to manifest keys (extended)
            if (/(bi·ªÉu\s*ƒë·ªì|xu\s*h∆∞·ªõng|trend|gi√°|price)/i.test(text)) return 'price_trend';
            if (/(volume|kh·ªëi\s*l∆∞·ª£ng)/i.test(text)) return 'volume_weekly';
            if (/(funding\s*rate|funding|basis)/i.test(text)) return 'funding_vs_close';
            if (/(volatility|bi·∫øn\s*ƒë·ªông|log\s*return)/i.test(text)) return 'volatility';
            if (/(composition|t·ª∑\s*tr·ªçng)/i.test(text)) return 'composition';
            if (/(heatmap|t∆∞∆°ng\s*quan|correlation)/i.test(text)) return 'correlation_heatmap';
            if (/(sentiment|t√¢m\s*l√Ω)/i.test(text)) return 'sentiment_trend';
            if (/(rsi|ch·ªâ\s*b√°o\s*s·ª©c\s*m·∫°nh)/i.test(text)) return 'rsi_indicator';
            if (/(moving\s*average|\bma\b|ƒë∆∞·ªùng\s*trung\s*b√¨nh)/i.test(text)) return 'moving_average';
            return null;
        }

        function chartTitle(intent) {
            switch (intent) {
                case 'price_trend': return 'Price Trend';
                case 'volume_weekly': return 'Weekly Volume';
                case 'funding_vs_close': return 'Funding vs Close';
                case 'volatility': return 'Volatility (Log Returns)';
                case 'composition': return 'Feature Composition';
                case 'correlation_heatmap': return 'Correlation Heatmap';
                case 'sentiment_trend': return 'Sentiment Trend';
                case 'moving_average': return 'Moving Average';
                case 'rsi_indicator': return 'RSI Indicator';
                default: return 'Chart';
            }
        }

        function tryComputeAveragePriceFromTotalCSV(text, symbol) {
            if (!/(gi√°\s*trung\s*b√¨nh|average\s*price|mean\s*price|gi√°\s*b√¨nh\s*qu√¢n)/i.test(text)) return null;
            if (!csvData || !csvData.length) return null;
            // Try to infer schema: look for columns like symbol and close
            const rows = csvData.filter(r => {
                const keys = Object.keys(r || {});
                const symbolKey = keys.find(k => /^(symbol|coin|ticker)$/i.test(k));
                if (symbolKey) return (r[symbolKey] + '').toUpperCase() === symbol;
                // else: if per-coin columns exist like BTC_Close
                const closeCol = keys.find(k => new RegExp(`^${symbol}[_\- ]?close$`, 'i').test(k));
                return typeof r[closeCol] !== 'undefined';
            });
            if (!rows.length) return null;
            // Compute close values
            let values = [];
            const keys = Object.keys(rows[0] || {});
            const symbolKey = keys.find(k => /^(symbol|coin|ticker)$/i.test(k));
            const closeKeyGeneric = keys.find(k => /^close$/i.test(k));
            const closeKeySpecific = keys.find(k => new RegExp(`^${symbol}[_\- ]?close$`, 'i').test(k));
            for (const r of rows) {
                let v = null;
                if (symbolKey && closeKeyGeneric) {
                    if ((r[symbolKey] + '').toUpperCase() === symbol) v = r[closeKeyGeneric];
                } else if (closeKeySpecific) {
                    v = r[closeKeySpecific];
                }
                if (typeof v === 'number' && isFinite(v)) values.push(v);
                else if (typeof v === 'string' && v.trim()) {
                    const n = parseFloat(v.replace(/,/g, ''));
                    if (!isNaN(n)) values.push(n);
                }
            }
            if (!values.length) return null;
            const sum = values.reduce((a,b)=>a+b,0);
            return sum / values.length;
        }

        // Helper: generic CSV value computation per metric
        function tryComputeValueFromCSV(symbol, metric) {
            const sym = String(symbol).toUpperCase();
            if (!csvData || !csvData.length) return null;
            const rows = csvData.filter(r => {
                const keys = Object.keys(r || {});
                const symbolKey = keys.find(k => /^(symbol|coin|ticker)$/i.test(k));
                if (symbolKey) return (r[symbolKey] + '').toUpperCase() === sym;
                const closeCol = keys.find(k => new RegExp(`^${sym}[_\- ]?close$`, 'i').test(k));
                return typeof r[closeCol] !== 'undefined';
            });
            if (!rows.length) return null;
            // Currently support avg_close; can extend later
            if (metric === 'avg_close') {
                let values = [];
                const keys = Object.keys(rows[0] || {});
                const symbolKey = keys.find(k => /^(symbol|coin|ticker)$/i.test(k));
                const closeKeyGeneric = keys.find(k => /^close$/i.test(k));
                const closeKeySpecific = keys.find(k => new RegExp(`^${sym}[_\- ]?close$`, 'i').test(k));
                for (const r of rows) {
                    let v = null;
                    if (symbolKey && closeKeyGeneric) {
                        if ((r[symbolKey] + '').toUpperCase() === sym) v = r[closeKeyGeneric];
                    } else if (closeKeySpecific) {
                        v = r[closeKeySpecific];
                    }
                    if (typeof v === 'number' && isFinite(v)) values.push(v);
                    else if (typeof v === 'string' && v.trim()) {
                        const n = parseFloat(v.replace(/,/g, ''));
                        if (!isNaN(n)) values.push(n);
                    }
                }
                if (!values.length) return null;
                const sum = values.reduce((a,b)=>a+b,0);
                return sum / values.length;
            }
            return null;
        }

        // Helper: compute average Close for a symbol without regex trigger (back-compat)
        function computeAverageCloseForSymbol(symbol) {
            return tryComputeValueFromCSV(symbol, 'avg_close');
        }

        // Simple average based on per-symbol CSV loaded into window.csvData
        function tryComputeAveragePricePerSymbol(symbol) {
            const sym = String(symbol).toUpperCase();
            if (!window.csvData || !Array.isArray(window.csvData[sym])) return NaN;
            const values = window.csvData[sym]
                .map(r => {
                    const v = r && (r.Close ?? r.close);
                    if (typeof v === 'number' && isFinite(v)) return v;
                    if (typeof v === 'string') {
                        const n = parseFloat(String(v).replace(/,/g, ''));
                        return isNaN(n) ? NaN : n;
                    }
                    return NaN;
                })
                .filter(n => typeof n === 'number' && isFinite(n));
            if (!values.length) return NaN;
            return values.reduce((a,b)=>a+b,0) / values.length;
        }

        // File Upload Handler
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const fileInfo = {
                id: Date.now(),
                name: file.name,
                type: file.type,
                size: file.size,
                file: file,
                uploadedAt: new Date()
            };

            uploadedFiles.push(fileInfo);
            updateFileList();

            // Read file content
            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                let preview = '';
                
                if (file.type === 'text/csv' || file.name.endsWith('.csv')) {
                    preview = `üìÑ File CSV: ${file.name} (${(file.size/1024).toFixed(2)} KB)\n\nƒê√£ t·∫£i l√™n th√†nh c√¥ng. B·∫°n c√≥ th·ªÉ h·ªèi v·ªÅ d·ªØ li·ªáu trong file n√†y.`;
                } else if (file.type.startsWith('text/') || file.name.endsWith('.txt')) {
                    const textPreview = content.substring(0, 500);
                    preview = `üìÑ File vƒÉn b·∫£n: ${file.name}\n\nN·ªôi dung:\n${textPreview}${content.length > 500 ? '...' : ''}`;
                } else if (file.name.endsWith('.json')) {
                    try {
                        const jsonData = JSON.parse(content);
                        preview = `üìÑ File JSON: ${file.name}\n\nD·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c t·∫£i. S·ªë keys: ${Object.keys(jsonData).length}`;
                    } catch {
                        preview = `üìÑ File JSON: ${file.name}\n\nFile ƒë√£ ƒë∆∞·ª£c t·∫£i l√™n.`;
                    }
                } else {
                    preview = `üìÑ File: ${file.name} (${(file.size/1024).toFixed(2)} KB)\n\nƒê√£ t·∫£i l√™n th√†nh c√¥ng.`;
                }

                // Add to chat
                addMessage(preview, 'user');
                chatHistory.push({ role: 'user', parts: [{ text: preview }] });
                
                // Store file content for sending to backend
                currentAttachments.push({
                    type: 'file',
                    name: file.name,
                    content: content,
                    mimeType: file.type
                });
                
                // Auto-send message with file context
                const autoMsg = `T√¥i ƒë√£ t·∫£i l√™n file ${file.name}. H√£y ph√¢n t√≠ch n·ªôi dung file n√†y.`;
                setTimeout(() => {
                    document.getElementById('messageInput').value = autoMsg;
                    sendMessage();
                }, 500);
            };

            if (file.type.startsWith('text/') || file.name.endsWith('.csv') || file.name.endsWith('.json') || file.name.endsWith('.txt')) {
                reader.readAsText(file);
            } else {
                addMessage(`üìÑ File ${file.name} ƒë√£ ƒë∆∞·ª£c t·∫£i l√™n (${(file.size/1024).toFixed(2)} KB)`, 'user');
                chatHistory.push({ role: 'user', parts: [{ text: `File ${file.name} uploaded` }] });
            }

            // Reset input
            event.target.value = '';
        }

        // Image Upload Handler
        async function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.type.startsWith('image/')) {
                alert('Vui l√≤ng ch·ªçn file ·∫£nh!');
                return;
            }

            const fileInfo = {
                id: Date.now(),
                name: file.name,
                type: file.type,
                size: file.size,
                file: file,
                uploadedAt: new Date()
            };

            uploadedFiles.push(fileInfo);
            updateFileList();

            // Read image as base64
            const reader = new FileReader();
            reader.onload = function(e) {
                const imageData = e.target.result;
                
                // Create preview in chat
                const previewHtml = `
                    <div class="message-attachment">
                        <p><strong>üñºÔ∏è ·∫¢nh ƒë√£ t·∫£i:</strong> ${file.name}</p>
                        <img src="${imageData}" alt="${file.name}" style="max-width: 100%; border-radius: 8px; margin-top: 8px;">
                    </div>
                `;

                // Add to chat
                const chatMessages = document.getElementById('chatMessages');
                const row = document.createElement('div');
                row.className = 'message-row right';
                row.innerHTML = `
                    <div style="flex: 1; display: flex; justify-content: flex-end;">
                        <div class="message user" style="max-width: 70%;">
                            ${previewHtml}
                            <div class="meta">${formatTime(new Date())}</div>
                        </div>
                    </div>
                    <div class="avatar user">You</div>
                `;
                chatMessages.appendChild(row);
                chatMessages.scrollTop = chatMessages.scrollHeight;

                chatHistory.push({ 
                    role: 'user', 
                    parts: [{ 
                        text: `[Image uploaded: ${file.name}]`,
                        imageData: imageData 
                    }] 
                });

                // Store image data for sending to backend
                currentAttachments.push({
                    type: 'image',
                    name: file.name,
                    data: imageData, // base64 data URL
                    mimeType: file.type
                });

                // Auto-send analysis request
                const autoMsg = `H√£y ph√¢n t√≠ch ·∫£nh n√†y: ${file.name}`;
                setTimeout(() => {
                    document.getElementById('messageInput').value = autoMsg;
                    sendMessage();
                }, 500);
            };

            reader.readAsDataURL(file);
            event.target.value = '';
        }

        // Update file list in sidebar
        function updateFileList() {
            const container = document.getElementById('fileListContainer');
            if (!container) return;

            container.innerHTML = '';
            
            if (uploadedFiles.length === 0) {
                container.innerHTML = '<p style="color: #6b7280; font-size: 12px; margin: 0;">Ch∆∞a c√≥ file n√†o</p>';
                return;
            }

            uploadedFiles.forEach(file => {
                const item = document.createElement('div');
                item.className = 'file-item';
                item.innerHTML = `
                    <span class="file-item-name" title="${file.name}">${file.name}</span>
                    <button class="file-item-remove" onclick="removeFile(${file.id})" title="X√≥a">√ó</button>
                `;
                container.appendChild(item);
            });
        }

        // Remove file
        function removeFile(fileId) {
            uploadedFiles = uploadedFiles.filter(f => f.id !== fileId);
            updateFileList();
        }

        // Export chat history
        function exportChat() {
            const dataStr = JSON.stringify(chatHistory, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `chat-history-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
            
            addMessage('‚úÖ ƒê√£ xu·∫•t l·ªãch s·ª≠ chat th√†nh c√¥ng!', 'bot');
        }

        // Import chat history
        function importChat() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const imported = JSON.parse(e.target.result);
                        if (Array.isArray(imported)) {
                            chatHistory = imported;
                            // Clear and reload
                            const chatMessages = document.getElementById('chatMessages');
                            chatMessages.innerHTML = '';
                            loadHistoryFromStorage();
                            addMessage('‚úÖ ƒê√£ nh·∫≠p l·ªãch s·ª≠ chat th√†nh c√¥ng!', 'bot');
                        }
                    } catch (err) {
                        alert('L·ªói khi ƒë·ªçc file: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // Toggle theme (placeholder)
        function toggleTheme() {
            addMessage('üåô T√≠nh nƒÉng ƒë·ªïi theme ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn!', 'bot');
        }

        // Show capabilities
        function showCapabilities() {
            const capabilities = buildCapabilitiesMessage();
            addMessage(capabilities, 'bot');
            chatHistory.push({ role: 'user', parts: [{ text: 'H∆∞·ªõng d·∫´n' }] });
            chatHistory.push({ role: 'model', parts: [{ text: capabilities }] });
            saveHistoryToStorage();
        }

        // Initialize file list on load
        window.addEventListener('DOMContentLoaded', () => {
            updateFileList();
        });
    </script>
</body>
</html>
